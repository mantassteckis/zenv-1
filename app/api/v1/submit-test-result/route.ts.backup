import { NextRequest, NextResponse } from 'next/server';
import { initializeApp, getApps, getApp } from 'firebase/app';
import { getFunctions, connectFunctionsEmulator, httpsCallable } from 'firebase/functions';
import { logger, createApiContext, createTimingContext } from '@/lib/structured-logger';
import { CORRELATION_ID_HEADER } from '@/lib/correlation-id';
import { withPerformanceMonitoring } from '@/src/lib/performance-middleware';

// Initialize Firebase Client SDK for Cloud Functions
const firebaseConfig = {
  apiKey: process.env.NEXT_PUBLIC_FIREBASE_API_KEY || "AIzaSyAipHBANeyyXgq1n9h2G33PAwtuXkMRu-w",
  authDomain: process.env.NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN || "solotype-23c1f.firebaseapp.com",
  projectId: process.env.NEXT_PUBLIC_FIREBASE_PROJECT_ID || "solotype-23c1f",
  storageBucket: process.env.NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET || "solotype-23c1f.firebasestorage.app",
  messagingSenderId: process.env.NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID || "39439361072",
  appId: process.env.NEXT_PUBLIC_FIREBASE_APP_ID || "1:39439361072:web:27661c0d7e4e341a02b9f5",
  measurementId: process.env.NEXT_PUBLIC_FIREBASE_MEASUREMENT_ID || "",
};

// Initialize Firebase with error handling
let app;
let functions;

try {
  app = !getApps().length ? initializeApp(firebaseConfig) : getApp();
  functions = getFunctions(app);
  console.log('✅ Firebase initialized successfully');
} catch (firebaseError) {
  console.error('❌ Firebase initialization failed:', firebaseError);
  throw new Error('Firebase initialization failed');
}

interface TestResultData {
  wpm: number;
  accuracy: number;
  errors: number;
  timeTaken: number;
  textLength: number;
  userInput: string;
  testType: string;
  difficulty: string;
  testId: string;
}

async function handlePOST(request: NextRequest) {
  const { startTime } = createTimingContext();
  const context = createApiContext(request, 'POST /api/v1/submit-test-result');
  
  try {
    logger.info(context, 'API Route: v1/submit-test-result called');
    logger.info(context, 'Firebase config validated', {
      apiKey: !!firebaseConfig.apiKey,
      projectId: firebaseConfig.projectId,
      authDomain: firebaseConfig.authDomain
    });
    
    // Get the authorization header - temporarily allow unauthenticated for testing
    const authHeader = request.headers.get('authorization');
    logger.info(context, 'Auth header validation', { authHeaderPresent: !!authHeader });
    
    let idToken = 'test-token-fallback';
    if (authHeader && authHeader.startsWith('Bearer ')) {
      idToken = authHeader.split('Bearer ')[1];
    } else {
      logger.warn(context, 'No valid auth header provided - using fallback for testing');
    }
    
    // Get test data from request body
    const testData = await request.json();
    logger.info(context, 'Test data received', { 
      wpm: testData.wpm, 
      accuracy: testData.accuracy, 
      testType: testData.testType,
      difficulty: testData.difficulty
    });

    // Call the Cloud Function with authentication context
    logger.info(context, 'Calling submitTestResult Cloud Function');
    
    if (!functions) {
      throw new Error('Firebase Functions not initialized');
    }
    
    const submitTestResult = httpsCallable(functions, 'submitTestResult');
    
    try {
      // Call the Cloud Function directly - authentication will be handled by the function itself
      const result = await submitTestResult(testData);
      
      logger.info(context, 'Cloud Function call successful', { 
        success: result.data.success,
        message: result.data.message
      });

      const correlationId = request.headers.get(CORRELATION_ID_HEADER) || 'unknown';
      const successResponse = NextResponse.json({ 
        success: true, 
        message: result.data.message || 'Test result saved successfully',
        correlationId
      });
      successResponse.headers.set(CORRELATION_ID_HEADER, correlationId);
      
      logger.logRequest(context, startTime, 200, { cloudFunctionSuccess: true });
      return successResponse;

    } catch (cloudFunctionError: any) {
      logger.error(context, cloudFunctionError, {
        errorCode: cloudFunctionError.code,
        errorMessage: cloudFunctionError.message
      });
      
      // Handle specific Cloud Function errors
      let statusCode = 500;
      let errorMessage = 'Internal server error';
      
      if (cloudFunctionError.code === 'unauthenticated') {
        statusCode = 401;
        errorMessage = 'Authentication required';
      } else if (cloudFunctionError.code === 'invalid-argument') {
        statusCode = 400;
        errorMessage = cloudFunctionError.message || 'Invalid request data';
      } else if (cloudFunctionError.code === 'resource-exhausted') {
        statusCode = 429;
        errorMessage = 'Rate limit exceeded';
      }
      
      const correlationId = request.headers.get(CORRELATION_ID_HEADER) || 'unknown';
      const errorResponse = NextResponse.json(
        { 
          error: errorMessage, 
          details: cloudFunctionError.message,
          correlationId
        },
        { status: statusCode }
      );
      errorResponse.headers.set(CORRELATION_ID_HEADER, correlationId);
      
      logger.logRequest(context, startTime, statusCode, { 
        cloudFunctionError: cloudFunctionError.message
      });
      return errorResponse;
    }

  } catch (error) {
    logger.error(context, error instanceof Error ? error : new Error(String(error)), {
      errorType: typeof error
    });
    
    const correlationId = request.headers.get(CORRELATION_ID_HEADER) || 'unknown';
    const errorResponse = NextResponse.json(
      { 
        error: 'Internal server error', 
        details: error instanceof Error ? error.message : 'Unknown error',
        type: typeof error,
        correlationId
      },
      { status: 500 }
    );
    errorResponse.headers.set(CORRELATION_ID_HEADER, correlationId);
    
    logger.logRequest(context, startTime, 500, { 
      errorMessage: error instanceof Error ? error.message : String(error)
    });
    return errorResponse;
  }
}

// Export the performance-monitored version
export const POST = withPerformanceMonitoring(handlePOST, {
  enablePayloadTracking: true,
  slowRequestThreshold: 2000, // 2 seconds for database operations
  maxPayloadSizeToLog: 5000
});